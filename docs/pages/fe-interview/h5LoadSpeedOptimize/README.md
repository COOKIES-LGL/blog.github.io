## 性能优化清单

*** 经典的H5页面加载包含以下过程： ***
- webview初始化
- html加载
- HTTP连接建立
- 请求
- html解析和渲染
- 解析html
- css/js
- 渲染
- 解析js
- 可交互
*** 各个过程的优化思路可以归纳为四点： ***
- 串行改并行；
- 缓存：最大化利用缓存；
- 过程提前：能提前执行尽可能提前；
- 尽可能缩减每个过程的耗时；

*** 优化手段 ***
客户端优化
- 预创建：提前创建WebView
- 预连接：冷启动下提前发起一起请求，预热通道，预创建是前提；
- 预请求：Api请求与WebView初始化、html加载并行；

*** 首屏性能优化 *** 

::: details
目标：尽快让用户看到首屏主要内容，避免白屏等待
:::

  1. ssr方案
    服务端
    流式渲染：将html从服务端分块输出，能够缩短首字节和首屏时间，html头部的提前输出能够提前css/js等重要资源的加载
    请求并行：首屏依赖的数据接口尽可能并行发出，缩短请求等待时间
    分块渲染：针对首屏依赖的慢请求，让其对应的模块先用骨架输出给客户端展示。待慢请求返回后，再生成内联js将真实内容替换骨架。
    减少渲染逻辑：
      非首屏、纯客户端组件只在客户端渲染，如返回顶部、前往app等组件
      商品列表组件减少首屏渲染个数，减少数据量
    客户端
      首屏css头部输出，js在首屏后执行（插入在html底部 或 添加defer 或在下一帧插入执行），避免阻塞页面渲染
      IOS渲染优化：body顶部添加空白字符优化渲染、js下一帧执行优化图片渲染

  2. 其他方案
    - 客户端预渲染预请求：客户端预载不可见webview加载目标页面，待用户真正需要进入时直接展示已加载好的页面内容
    - html强缓存：服务端设置强缓存头，让客户端缓存html，后续客户端直接取缓存html渲染并通过js动态更新页面数据。适合首页等场景
    - 带图加载：将前置页面加载过的图片资源，直接作为后续页面的头图展示，可利用缓存快速展示。适合商详等场景
    - Critical CSS：​Critical CSS​
    - 资源preload：​【资源 Prefetch】端内静态资源预加载 - 高流量页面全覆盖​
    - JS分片执行：​JS分片初始化-接入​
    - 商品图规范：​商品图规范resizeWidth统一​
    - JS体积优化：​initial js bundle体积优化​

*** 可交互时间优化 *** 

::: details

目标：尽快开始响应用户的操作，避免操作无效
::: 
加速js加载
  cdn
  客户端资源包
精简js体积
  模块懒加载（可依赖loadable components提供的能力）
  非首屏依赖的js模块延迟加载
  特定环境、特定条件依赖的js模块可选加载，如风控包可仅在非app环境或app不支持提供风控token的版本才加载
  大模块精简：preact替换react，简单场景移除mobx
  polyfill动态加载：针对ua判断，按需引入polyfill
  部署es2015脚本：针对现代浏览器的脚本优化方案
渐进式补水：逐步进行补水，先补水必要的部分（首屏、用户极有可能交互的部分），再根据适当的时机补水其他部分

*** 交互体验优化 *** 

::: details
目标：尽快给用户操作反馈，避免卡顿，包括tab流畅切换、滚动不掉帧等
:::
  图片懒加载：不可见图片进入可视区域才开始加载，避免影响可视区资源加载
  虚拟列表：不在可视范围的内容使其避免渲染，可优化多tab+长列表等场景，
  骨架：异步请求数据未返回之前，可用美丽的骨架进行占位
  回退缓存：html快照实现回退定位，
  视频转webp动图：加快加载
  tab手势横滑
