---
title: 性能优化
---

SSR 带来的性能提升主要在以下几点：

1. SSR 直出 HTML 可缩短首屏时间减少用户等待
2. Node 内网接口调用相比用户公网环境调用 RT 更短

主要也是围绕着 SSR 上述流程中的各个节点结合浏览器/ Node 特性进行优化：

## Stream 渲染

## 更快的接口调用速度

通过使用 `Promise.all` 可以并发处理发起两个请求，因此， fetch 的响应时间为 `Max(data1, data2)`，可以极大的提升请求耗时。

## 减少首屏抖动

HTML 进入浏览器渲染时，由于页面抖动，会导致浏览器频繁触发重排和重绘，既影响用户体验，又影响页面性能，因此，我们需要确保 SSR 渲染结果在浏览器渲染时尽可能减少抖动，因此需要考虑如下点：

- img、video 等媒体元素都显式的声明宽高（图片使用 BImage 组件）
- 无法在 node 环境渲染的组件提供占位空节点，使用 LazyLoad 组件 在客户端进行 rerender

## 控制首屏大小

为了最快响应用户请求，我们希望服务端能尽可能快的交付页面渲染结果。因此，在 SSR 中，我们更关心首屏重要内容优先渲染，这样有几个好处：

- 更多的内容可能需要调用更多的接口，可能造成接口请求瓶颈
- 更多的内容渲染需要执行更多的 jsx 代码，耗时更高
- 更多的内容会造成 Node 占用更多内存
- 更多的内容浏览器需要加载更多的数据，网络耗时更久
- 更多的内容浏览器解析 HTML 和绘制的时间也成倍增加

控制首屏大小的边界在哪里呢？可能涉及如下场景：

- 列表页只加载第一页数据
- Tab 只加载第一个 Tab（或选中的 Tab）数据
- RT 慢的非关键请求放到 CSR 阶段请求渲染

### 如何控制首屏内容？

上文提到需要将非首屏内容延迟渲染，具体实际代码中如何延迟呢？有以下几种典型的场景：

#### 纯列表页

这种场景比较简单，只需根据页面 UI 按照一定经验值控制首页 pageSize 即可，例如上面的商品列表，可见大部分手机首屏可展示的商品数量不超过 5 个楼层（即 10 个商品），我们把首屏请求的 pageSize 设为 10 即可，后面的页面可能根据需求，pageSize 为 20 或者更少。

#### Tab 页

Tab 页场景也比较典型，只有被激活的 tab 区域才应该在服务端直出，而其他 tab 内容完全可以等到 CSR 阶段（或点击时）再触发渲染。

#### 多个楼层

这个页面包含 banner、精选直播课、为你推荐、精品系列课等多个楼层，但是在手机有限的屏幕高度限制下，只有红框内属于首屏内容，因此完全可以将【精品系列课】楼层等到 CSR 环境下再进行渲染，减小首屏大小。如何控制非首屏内容渲染呢，可以使用 LazyLoad 组件

## 图片控制

图片的加载在整个页面性能中占据重要的比重，值得单独进行优化。

### 选择正确的图片格式

不同图片格式的适用场景、文件大小都有所差异，选择适合的图片格式能更好的兼顾性能与显示效果。具体的图片优劣势网上已经有很多文章谈到，这里不再赘述，一般来讲我们可以按照以下场景选择相应的图片格式：

- 【jpg】普通商品图、banner 等包含文字、色彩丰富
- 【png】包含透明通道
- 【svg】矢量图、icon
- 【gif】色彩简单的动画
- 【webp】支持 webp 格式的浏览器统一都用 webp

### 文件大小控制

更大的文件尺寸需要消耗更多的加载时间，对文件大小的控制我们也可以遵循以下基本规律。

#### 图片尺寸

下图显示了不合理的图片尺寸对文件大小的影响，在使用图片时，我们需要根据显示尺寸合理的剪裁图片，假设需要在一个 100\*100 的 div 上展示一个背景图，那么我们的图片自然尺寸应该和 div 尺寸保持一致，并根据设备 DPI 选择 2 倍或 3 倍图。

#### 图片质量

图片质量对文件大小的影响也是显而易见的，但同时，图片质量也会对显示效果造成影响，一般来讲我们可以按照以下场景选择相应的图片格式：

**JPG/WEBP**

- 【80】包含渐变等带有过渡效果的图片
- 【70】包含文字的图片
- 【50】普通图片

对于 jpg 而已，图片质量对显示效果的影响呈现边际递减效应，一般图片质量超过 90 就很难肉眼看到差异了，因此没必要为了追求极端的质量而导致体积增加。

**PNG**

使用 CDN 提供的 PNG 无损压缩。

#### 去除元信息

很多图片在导出时都包含大量的元信息，包含 exif 信息等，这些元信息也显著影响着图片的尺寸，因为在使用前，我们需要将图片元信息清除。

### 渐进加载

为了更快的首屏展示，我们希望图片能够渐进加载，让用户先看到内容、再看到更清晰的内容。因此，我们需要考虑在服务端渲染直出的图片大小在 kb 级别（参考上文的文件大小控制，以极小的图片尺寸、极低的图片质量将图片控制在 kb 大小），等首屏渲染完成后，再将小图替换为高清大图。

#### 合理的图片请求数

虽然目前浏览器已经有充足的并发请求数量，但我们仍然需要考虑大量请求并发造成的网络资源竞争问题，因此需要将首屏的图片请求数（甚至是资源请求数）控制在合理的范围，我们需要考虑以下场景：

- 非可视区域内的图片不请求（不在首屏的图片、轮播第二屏的图片、横向滚动不在可视区的图片等）
- 合理控制轮播图的速度
- 合理使用预加载

#### 自适应图片

有两种场景下应该对图片的尺寸、格式进行自适应：

- 根据用户设备 DPI（每英寸像素点数）动态调整图片倍率
- 根据用户网络动态调整图片大小（弱网使用更小的图片尺寸和倍率、更高的压缩比）

#### 显示效果调优

当 JPG 图片经过上面提到的压缩后，会对显示效果造成一定的影响，为了在压缩后提供更好的现实效果，我们可以通过以下参数进行一定的调优：

- 在高分辨率屏幕上使用多倍图
- 通过 sharpen 参数增加图片锐度（对于包含文字等有大量清晰边界线的图片，可适度提高图片锐度参数）
- 通过以上两种手段在一定程度上可以让用户显示效果更好。

## JS 体积优化

### 检查重复依赖

重复依赖不仅会导致 JS 体积增大，部分模块存在多个版本甚至会引发线上故障，因此请自查是否有重复依赖问题，可在项目根目录运行模块分析命令进行检查，如果有将重复的依赖 resolutions 到最高的版本 (跨大版本请严格测试)：

```bash
npx pin webpack --analyze
```

### lodash 按需引用

### 推荐使用 dayjs 替换 moment
